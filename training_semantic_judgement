# -*- coding: utf-8 -*-
"""
Created on Mon Mar  5 14:48:51 2018

"""
''' This is a script to run the blocked and mixed experiment.
Instruction:
In this experiment, participants will be asked to match words based on their features - colour,size or shape.\n" + "  \n" +  
The feature will change on each trial and will be indicated by the top word on the screen.\n" +  
Subjects need to determine whether the probe and target shares the same feature.

The script will create a folder called data_FeatureMatchingExperiment under the folder of the script
Capture the info of each subject - experiment time, ID, name
Generate a csv file for each subject
Store the data in that csv file, inclduing the info about each trial, fixa_onset,offset, clue_onset,offset and so on.

Trial num =
Run num =
Trial time = 
Run time = 
'''
from psychopy import visual, core, monitors, event, sound, gui, logging
from datetime import datetime
from random import shuffle
import os
import time
import csv
import sys, os, errno # to get file system encoding (used in setDir())
import numpy as np
import random
from collections import OrderedDict

# Experiment constants
instruct_file = 'semantic_relation_instru.csv' 
rest_file = 'semantic_relation_judgement_rest.csv'

#stimuli_file = 'feature_matching_stimuli_exp_test.csv'
expName = 'BlockedDesignSemanticRelationJudgement'  # the experiment name
data_folder = 'data' + '_' +  expName  # make a directory to store data
stimuli_name = 'sem_stim_run'
fixa_name = 'sem_fixa_run'
# assign the monitor name
monitor_name = 'HP ProOne 600'

# window size = x, y
win_size_x = 1920
win_size_y = 1080

# window background color
win_bg_col   = (1.0,1.0,1.0) # background color is black
win_text_col = (-1,-1,-1)  # text color is white

# instruction, position height (font size)
instru_pos = (0,0) # (0,0) indicates the central position
clue_pos = (0,0)
fixa_pos = (0,0)
remin_pos = (0,0)
probe_pos = (0,0)
target_pos = (0,0)
yes_pos = (-250,-180)
no_pos = (250,-180)
image_pos = (0,0)

instru_h = 80
text_h = 100
yes_no_h = 62

# probe and target same screen
#fixa_pos   = (0,230)
#clue_pos   = (0,230)
#probe_pos  = (0,50)
#target_pos = (0,-180)
#yes_pos  =(-50,-180)
#no_pos   = (50, -180)


num_skip_trials = 1  # the number of trials that can be skipped, used for testing the scirpt

# have a rest parameters
rest_num = 100 # after every rest_num, subjects can have a rest
rest_time = 2 # subjects can have a break for rest_time

num_trials = 15 # total trial numbers of each run 


# presentation time of clue and probe
clue_time = 1
probe_time = 1

# response time 
timelimit_deci = 2.5   # previous is 2.5
## define functions

# get the current directory of this script - correct
def get_pwd():
    global curr_dic
    curr_dic = os.path.dirname(sys.argv[0])  # U:/task_fMRI_Experiment/exp_March
    return curr_dic
    
# make a folder in the current directory used to store data  - correct
def makedir(folder_name):
    os.chdir(curr_dic)
    if not os.path.exists(folder_name):
        os.makedirs(folder_name)

def generate_jitter_list(trial_num,start,stop):
    '''
    trial_num is the number of trials, which means how many random jitter you need to generate
    start and stop is used to return a random interger N sucha that a <=N <= b.
    start = 20
    stop = 30
    
    is not necessary in this exp
    '''
    jitter_list = []
    for i in range(trial_num):
        jitter_time = random.randint(start,stop)/10.0
        jitter_list.append(jitter_time)
    jitter_sum  = sum(jitter_list)
    jitter_mean = jitter_sum/float(len(jitter_list))
    
    return jitter_list,jitter_sum,jitter_mean

# quit functions  - to allow subjects to quit the experiment  - correct
def shutdown ():
    win.close()
    core.quit()
    
# get the participants info, initialize the screen and create a data file for this subject
def info_gui(expName):
    # Set up a dictionary in which we can store our experiment details
    expInfo={}
    expInfo['expname'] =expName
    # Create a string version of the current year/month/day hour/minute
    expInfo['expdate']=datetime.now().strftime('%Y%m%d_%H%M')
    expInfo['subjID']=''
    expInfo['subjName']=''
    expInfo['run']=''
    
    # Set up our input dialog
    # Use the 'fixed' argument to stop the user changing the 'expname' parameter
    # Use the 'order' argumennt to set the order in which to display the fields
    dlg = gui.DlgFromDict(expInfo,title='input data', fixed = ['expname','expdate'],order =['expname','expdate','subjID','subjName','run'])
    
    if not dlg.OK:
        print ('User cancelled the experiment')
        core.quit()
   
# creates a file with a name that is absolute path + info collected from GUI
    filename = data_folder + os.sep + '%s_%s_%s_%s.csv' %(expInfo['subjID'], expInfo['subjName'], expInfo['expdate'], expInfo['run'])
    stimuli_file = stimuli_name +expInfo['run']+'.csv'
    fixa_file = fixa_name + expInfo['run']+'.csv'
    return expInfo, filename,stimuli_file,fixa_file
# to avoid overwrite the data. Check whether the file exists, if not, create a new one and write the header.
# Otherwise, rename it - repeat_n
# correct
def write_file_not_exist(filename):
    repeat_n = 1
    while True:
        if not os.path.isfile(filename):
            f = open(filename,'w')
           # f.write(header)
            break
        else:
            filename = data_folder + os.sep + '%s_%s_%s_repeat_%s.csv' %(expInfo['subjID'], expInfo['subjName'], expInfo['expdate'],str(repeat_n))
            repeat_n = repeat_n + 1


# Open a csv file, read through from the first row   # correct
def load_conditions_dict(conditionfile):

#load each row as a dictionary with the headers as the keys
#save the headers in its original order for data saving

# csv.DictReader(f,fieldnames = None): create an object that operates like a regular reader 
# but maps the information in each row to an OrderedDict whose keys
# are given by the optional fieldnames parameter.

    with open(conditionfile) as csvfile:
        reader = csv.DictReader(csvfile)
        trials = []

        for row in reader:
            trials.append(row)
    
    # save field names as a list in order
        fieldnames = reader.fieldnames  # filenames is the first row, which used as keys of trials

    return trials, fieldnames   # trial is a list, each element is a key-value pair. Key is the 
                                # header of that column and value is the corresponding value

# Create the log file to store the data of the experiment 
# create the header

            
def write_header(filename, header):
    with open (filename,'a') as csvfile:
        fieldnames = header
        data_file = csv.DictWriter(csvfile,fieldnames=fieldnames,lineterminator ='\n')
        data_file.writeheader()
        
#write each trial
def write_trial(filename,header,trial):
    with open (filename,'a') as csvfile:
        fieldnames = header
        data_file = csv.DictWriter(csvfile,fieldnames=fieldnames,lineterminator ='\n')
        data_file.writerow(trial)


def read_fix_from_csv(fixa_file):
    
    """
    read random fixation file from fixa_file and shuffle and write them in a list
    fixa_file is the random fixa time file
    argument:sem_fixa_run1.csv, sem_fixa_run2.csv,sem_fixa_run3.csv,sem_fixa_run4.csv
    
    """

    f = open(fixa_file,'r')    
    fixa_list = []   
    
    for line in f.readlines():
        line = line.strip()     
        line = float(line)
        fixa_list.append(line)
    
    #random.shuffle(fixa_list)
    
    return fixa_list , sum(fixa_list)

# generate the ideal onset of each trial

def gen_ideal_onset(fixa_list,num_trials):
    
    ideal_trial_onset =[]
    
    for trial_num in range(1, num_trials+1,1):
        
        if trial_num ==1:
            trial_onset = 0
        else:
            fixa_sum =0
            for fixa_index in range(0,(trial_num-1)*3,1):
                fixa_sum+=fixa_list[fixa_index]
            trial_onset = fixa_sum + (clue_time + probe_time + timelimit_deci)*(trial_num -1)

        ideal_trial_onset.append(trial_onset)
    return ideal_trial_onset 

# set up the window
# fullscr: better timing can be achieved in full-screen mode
# allowGUI: if set to False, window will be drawn with no frame and no buttons to close etc...

def set_up_window(): 
    mon = monitors.Monitor(monitor_name)
    mon.setDistance (114)
    win = visual.Window([win_size_x,win_size_y],fullscr = True, monitor = mon,allowGUI = True, winType = 'pyglet', units="pix",color=win_bg_col)
    win.mouseVisible = False  # hide the mouse
    return win
        
# read the content in the csv or text file
def read_cont (filename):
    f = open(filename,'r')
    return f

# prepare the content on the screen - content is text
def prep_cont(line, pos, height):
    line_text = visual.TextStim(win,line,color = win_text_col,pos = pos,height = height)
    return line_text


# prepare the content on the screen - pictures
# create an image stimulus for presenting the images in
# set this to None and then you can update as you go by calling in images from a file for example
    
    # prepare the image on the screen 
def prep_image(image,pos):
    image_stim = visual.ImageStim(win,image,pos = pos)
    return image_stim
    
# display the content on the screen
def disp_instr_cont(line):
    line.draw()
    win.flip()
    keys = event.waitKeys(keyList =['return','escape'])
    if keys[0][0]=='escape':
        shutdown()
        
def instruct():
    """
    path is where the instruct figure stored
    instruct_figure is the name of instruct_figure
    """
    instruction_1 = visual.ImageStim(win,image = 'instruction_1.jpg',pos = (0,0))
    instruction_2 = visual.ImageStim(win,image = 'instruction_2.png',pos = (0,0))
    instruction_3 = visual.ImageStim(win,image = 'instruction_3.png',pos = (0,0))
    instruction_4 = visual.ImageStim(win,image = 'instruction_4.png',pos = (0,0))
    instruction_5 = visual.ImageStim(win,image = 'instruction_5.png',pos = (0,0))
    instruction_1.draw()
    win.flip()
    event.waitKeys(keyList=['return','escape','space'],timeStamped = True)
    instruction_2.draw()
    win.flip()
    event.waitKeys(keyList=['return','escape','space'],timeStamped = True)
    instruction_3.draw()
    win.flip()
    event.waitKeys(keyList=['return','escape','space'],timeStamped = True)
    instruction_4.draw()
    win.flip()
    event.waitKeys(keyList=['return','escape','space'],timeStamped = True)
    instruction_5.draw()
    win.flip()
    event.waitKeys(keyList=['return','escape','space'],timeStamped = True)
    if keys[0][0]=='escape':
        shutdown()
    
def trigger_exp():

    trigger = prep_cont('trigger the scanner',instru_pos,instru_h)
    trigger.draw()
    win.flip()
    
def ready():

    trigger = prep_cont('experiment starts soon',instru_pos,instru_h)
    trigger.draw()
    ready_onset = win.flip()
    return ready_onset
    
def end_exp():

    trigger = prep_cont('End of Experiment',instru_pos,instru_h )
    trigger.draw()
    end_onset = win.flip()
    keys = event.waitKeys(keyList =['return'],timeStamped = True)
    print ('end of experiment:',end_onset)
    shutdown()
    return end_onset

# read the rest
def rest():
    f = read_cont(rest_file)
    for line in f.readlines():
        line.split('\n')
        line_text = prep_cont(line,instru_pos,text_h)
        disp_instr_cont(line_text) 

        
# display each trial on the screen at the appropriate time
def run_stimuli(stimuli_file,fixa_list):
    """
    stimuli file is sem_stim_runi.csv file, including the stimuli for each run
    
    fixa_list is a list, including random jittered fixation time for each trial
    
    """
    # read the stimuli  # re-define, not use numbers, but use keywords
    all_trials, headers = load_conditions_dict(conditionfile=stimuli_file)
    headers += ['trial_pres_num', 'conditions', 'StimType', 'fixa1_onset', 'fixa1_durat', 'clue_onset', 'clue_durat','fixa2_onset', 'fixa2_durat', 'probe_onset','probe_durat', 'fixa3_onset', 'fixa3_durat', 'target_onset', 'target_offset','RT', 'correct','KeyPress'] 
    
    # read the fixation duration
#    all_fixa, fixa_headers = load_conditions_dict(conditionfile=fixa_file)
    # open the result file to write the heater
    
    write_header(filename,headers) 
    
#    
#    
    shuffle(all_trials) #- 
    trial_pres_num = 1 # initialize a counter (so that we can have mini-blocks of 10)
    fixa_num = 0          
    
    #trigger the scanner
    #trigger_exp()
    #event.waitKeys(keyList=['5'], timeStamped=True)
    #  remind the subjects that experiment starts soon.
    ready()
    core.wait(3)  # 2 TRs
    run_onset = win.flip() 
    
    print ('run_onset',run_onset)
    
    for trial in all_trials: 
        
       
        #''' trial is a ordered dictionary. The key is the first raw of the stimuli csv file'''
          
        # prepare fixation, clue, probe and target for dispaly
        fixa_1   = visual.TextStim(win,'+',color = (1,0,0),pos = fixa_pos,height = text_h)
        fixa  = prep_cont(trial['fixa'],fixa_pos,text_h)
        
        clue = prep_cont(trial['circle'],clue_pos,text_h)
        probe = prep_cont(trial['circle'],probe_pos,text_h)
        target = prep_cont(trial['circle'],target_pos,text_h)
        yes   = prep_cont('Y',yes_pos,yes_no_h)
        no    = prep_cont('N',no_pos,yes_no_h)
        sound_clue = sound.Sound(value = trial['clue'])
        sound_probe = sound.Sound(value = trial['probe'])#prep_sound(trial['probe'])
        sound_target = sound.Sound(value = trial['target']) #prep_sound(trial['target'])
        
        # draw fixation and flip the window
        fixa_1.draw()
#        timetodraw = core.monotonicClock.getTime()
        timetodraw = run_onset + ideal_trial_onset[trial_pres_num-1]
        while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
            pass
        fixa1_onset = win.flip()
        
        # draw clue and filp the window

        clue.draw()
        timetodraw = fixa1_onset + fixa_list[fixa_num]
#        sound_1.setSound(trial['clue'])
#        sound_1.setVolume(1,log=False)
#        win.callOnFlip(sound_1.play)
        while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
            pass  
        clue_onset = win.flip()
        sound_clue.play()
        
         # draw fixa between clue and probe and flip the window
        fixa.draw()
        timetodraw = fixa1_onset + fixa_list[fixa_num] + clue_time
        while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
            pass
        fixa2_onset = win.flip()
        
      
         # draw probe and filp the window
        probe.draw()
        timetodraw = fixa1_onset + fixa_list[fixa_num] + clue_time + fixa_list[fixa_num +1]
        
        while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
            pass       
        probe_onset = win.flip()
        sound_probe.play()
        
        # draw fixa between probe and target and flip the window
        fixa.draw()
        timetodraw = fixa1_onset + fixa_list[fixa_num] + clue_time + fixa_list[fixa_num +1] + probe_time
        while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
            pass
        fixa3_onset = win.flip()
        
        # draw target and flip the window           
        target.draw()
        timetodraw = fixa1_onset + fixa_list[fixa_num] + clue_time + fixa_list[fixa_num +1] + probe_time + fixa_list[fixa_num +2]
        while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
            pass

        event.clearEvents()
        target_onset = win.flip()
        sound_target.play()
        keys = event.waitKeys(maxWait = timelimit_deci, keyList =['1','2','escape'],timeStamped = True)
        

        # If subjects do not press the key within maxwait time, RT is the timilimit and key is none and it is false
        if keys is None:
            RT = 'None'
            keypress = 'None'
            correct = 'False'
            target_offset = target_onset+ timelimit_deci

            #write_trial(filename,headers,trial) 

    # If subjects press the key, record which key is pressed, RT and whether it is right
    #
        elif type(keys) is list:
            if keys[0][0]=='escape':
                shutdown()
            
            else:
                keypress = keys[0][0]
                RT = keys[0][1] - target_onset
                correct = (keys[0][0]==trial['correct_answer']) 
                target_offset = keys[0][1] 
                trial['RT']=RT
                trial['correct'] = correct
                trial['KeyPress'] = keypress
        trial['trial_pres_num']=trial_pres_num
        trial['fixa1_onset'] = fixa1_onset - run_onset
        trial['fixa1_durat']= fixa_list[fixa_num]
        trial['clue_onset'] = clue_onset -run_onset
        trial['clue_durat'] = clue_time
        trial['fixa2_onset'] = fixa2_onset -run_onset
        trial['fixa2_durat']= fixa_list[fixa_num+1]
        trial['probe_onset'] = probe_onset - run_onset
        trial['probe_durat']= probe_time
        trial['fixa3_onset'] = fixa3_onset - run_onset
        trial['fixa3_durat']= fixa_list[fixa_num+2]
        trial['target_onset'] = target_onset - run_onset
        trial['target_offset'] = target_offset - run_onset
        trial['RT'] = RT
        trial['correct'] = correct
        trial['KeyPress'] = keypress
        
        trial_pres_num +=1 # the number-th presentnted trial
        write_trial(filename,headers,trial)     # calls the function that writes csv output
       
        # display a final fixation again. The fixation time = timelimit_deci - RT
        if keys is not None:
            target.draw()
            #yes.draw()
            #no.draw()
            win.flip()
            timetodraw = fixa1_onset + fixa_list[fixa_num] + clue_time + fixa_list[fixa_num +1] + probe_time + fixa_list[fixa_num +2] + timelimit_deci
            while core.monotonicClock.getTime() < (timetodraw - (1/120.0)):
                pass
                
        fixa_num+=3 # the number-th fixation

        
# -----------------------------------------------------------------------------------------------------------------------------------------------
# call the functions defined
# get the current directory
curr_dic = get_pwd()

# make a directory – data to store the generated data
makedir(data_folder)

# record subjects info and create a csv file with the info about subjects
expInfo, filename, stimuli_file,fixa_file = info_gui(expName)

# if the data does not exist, create one, otherwise,  rename one –filename-repeat-n
write_file_not_exist(filename)

# set up the window to display the instruction
win = set_up_window()

# read the instruction
# instruct()

# generate the jitter list for the fixation and probe
# know the number of trials
trials, fieldnames = load_conditions_dict(stimuli_file)
trials_num = len(trials)

fixa_list,total_fixa_time = read_fix_from_csv(fixa_file)

ideal_trial_onset = gen_ideal_onset(fixa_list,num_trials)  # ideal onset list of each trial      
### use 

#instruct()
# Trigger the scanner
# displays that experiment is about to start -  waiting for dummy volumes to be acquired     
# experimenter does not have to press 5. The scanner would be triggered in this way. 
# This is not useful for the behaviour experiment    
# expSoon.draw()
#trigger_exp()
#event.waitKeys(keyList=['5'], timeStamped=True)

# Lucilla would like to discard some volumes at the beginning of the scanning - Xiuyi.
# That's why she asked her experiment to wait for 4s to start. - Xiuyi
# Not useful for the behaviour experiment
#ready()
#core.wait(4)  # 2 TRs
#run_onset = win.flip()

# sets a local clock that will be used to store timing information synced with the scanner
expClock = core.Clock()
expClock.reset()   

# run the stimuli
run_stimuli(stimuli_file,fixa_list)

# end of the experiment
end_onset = end_exp()

print ('end onset',end_onset)

    
    
# Experiment()   
